use geosets_rs::sets::GeoSet;
use ndarray::Array1;
use rstest::rstest;

// This module contains common tests for the GeoSet trait.
// These tests are implementation-agnostic and apply to any type implementing GeoSet.

#[rstest]
#[case::hpolytope(std::marker::PhantomData::<geosets_rs::HPolytope>)]
#[case::zonotope(std::marker::PhantomData::<geosets_rs::Zonotope>)]
fn test_dim_common<T: GeoSet>(#[case] _marker: std::marker::PhantomData<T>) {
    for dim in 2..5 {
        if let Ok(set) = T::from_unit_box(dim) {
            assert_eq!(set.dim(), dim);
        }
    }
}

#[rstest]
#[case::hpolytope(std::marker::PhantomData::<geosets_rs::HPolytope>)]
#[case::zonotope(std::marker::PhantomData::<geosets_rs::Zonotope>)]
fn test_empty_common<T: GeoSet>(#[case] _marker: std::marker::PhantomData<T>) {
    if let Ok(set) = T::from_unit_box(2) {
        assert!(!set.empty(), "Unit box should not be empty");
    }
}

/// Tests that the center method returns the expected value for a unit box
pub fn test_center<T: GeoSet>() {
    // The center of a unit box should be all zeros
    for dim in 2..5 {
        if let Ok(set) = T::from_unit_box(dim) {
            if let Ok(center) = set.center() {
                assert_eq!(
                    center.len(),
                    dim,
                    "Center dimension should match the set dimension"
                );

                // For a unit box centered at the origin, all coordinates should be 0
                for val in center.iter() {
                    assert_eq!(*val, 0.0, "Center of unit box should be at the origin");
                }
            }
        }
    }
}

/// Tests that the translate method correctly shifts the set
pub fn test_translate<T: GeoSet>() {
    for dim in 2..5 {
        if let Ok(set) = T::from_unit_box(dim) {
            // Create a translation vector filled with 1.0
            let translation = Array1::from_elem(dim, 1.0);

            if let Ok(translated) = set.translate(&translation) {
                // The dimension should remain the same
                assert_eq!(
                    translated.dim(),
                    dim,
                    "Dimension should not change after translation"
                );

                // The center should be translated by the vector
                if let (Ok(orig_center), Ok(new_center)) = (set.center(), translated.center()) {
                    for i in 0..dim {
                        assert_eq!(
                            new_center[i],
                            orig_center[i] + translation[i],
                            "Center should be translated by the vector"
                        );
                    }
                }
            }
        }
    }
}

/// Tests that the volume calculation is correct
pub fn test_volume<T: GeoSet>() {
    // The volume of a unit box should be 1.0 for any dimension
    for dim in 2..5 {
        if let Ok(set) = T::from_unit_box(dim) {
            if let Ok(volume) = set.volume() {
                assert!(
                    (volume - f64::powf(2.0, dim as f64)).abs() < 1e-10,
                    "Volume of unit box should be 1.0, got {}",
                    volume
                );
            }
        }
    }
}


#[test]
fn test_center_common() {
    // This will test center() for all GeoSet implementations
    // test_center::<HPolytope>();
    // test_center::<Zonotope>();
}

#[test]
fn test_translate_common() {
    // This will test translate() for all GeoSet implementations
    // test_translate::<HPolytope>();
    // test_translate::<Zonotope>();
}

#[test]
fn test_volume_common() {
    // This will test volume() for all GeoSet implementations
    // test_volume::<HPolytope>();
    // test_volume::<Zonotope>();
}
